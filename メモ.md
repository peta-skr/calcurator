了解！コードは書かずに、**RPN（逆ポーランド記法）＋ Shunting Yard** で電卓の計算処理を実装するための考え方と手順を、実務寄りにまとめます。

---

# 全体像（流れ）

1. **トークナイズ**：入力文字列を「数値」「演算子」などの最小単位に分解する
2. **RPN 変換（Shunting Yard）**：中置（例：`1+2*3`）を後置（例：`1 2 3 * +`）へ並び替え
3. **RPN 評価**：スタックで後置式を評価して最終結果を得る
4. **エラー処理**：ゼロ割・8 桁超・無効入力を検知して「ERR」を返す（UI では ERR 表示）

---

# 1. トークナイズのポイント

- **扱うトークン種別**：

  - 数値（整数）：例 `0`、`123`、`-45`
  - 演算子：`+` `-` `*` `/`
  - （今回は括弧なし）

- **単項マイナスの扱い**（重要）：

  - 式の先頭、または演算子の直後に現れる `-` は **数値の符号** とみなす
  - 例：`-3*5` は「`-3`」「`*`」「`5`」の 3 トークン
  - 例：`2*-3` は「`2`」「`*`」「`-3`」

- **空白の無視**：スペースやタブは読み飛ばす
- **不正文字の検出**：数字と `+-*/` 以外はエラー
- **桁数制限（入力中）**：UI 側で制御しておくと楽（9 桁目は無視）
  ※計算結果の 8 桁制限は後段で判定

---

# 2. Shunting Yard（中置 →RPN 変換）要点

- **優先順位**：`*` と `/` が `+` と `-` より優先
- **結合性**：すべて左結合（同優先なら先に現れた方を先に処理）
- **使う入れ物**：

  - **出力列**（RPN の並び）
  - **演算子スタック**（一時的に演算子を退避）

- **処理ルール**（括弧なし版）

  - 数値 → 出力列に追加
  - 演算子 → スタック上に **自分以上の優先度** の演算子がある限り、それらを出力列に移し、最後に自分を積む
  - 入力が終わったら、スタックの演算子をすべて出力列に移す

- **例**：`1 + 2 * 3`

  - RPN は `1 2 3 * +`（乗除が先）

---

# 3. RPN の評価（スタック法）

- **使う入れ物**：

  - **数値スタック**（数値を積んでいく）

- **手順**

  1. RPN を左から読む
  2. 数値ならスタックに積む
  3. 演算子なら、2 つ取り出して（取り出し順に注意：先に出た方が左オペランド）、計算して戻す
  4. 最後にスタックに 1 つだけ残っていればそれが結果

- **左結合の確認例**：`8 2 / 2 /` は `(8/2)/2` で `2`

---

# 4. 設計上の決めごと（電卓仕様に合わせる）

- **丸めルール**（整数電卓）：

  - 割り算は **0 方向丸め**（小数は切り捨て。`-7/3` は `-2`）

- **8 桁制限（結果）**：

  - **絶対値が 99,999,999 を超えた時点**でエラー（中間計算も含めて都度チェックすると安全）
  - UI では「ERR」を表示

- **ゼロ割り**：

  - 計算中に割る数が 0 → エラー（UI では「ERR」）

- **入力エラー**（例：オペランド不足、未知の文字）

  - エラーとして扱い、UI で「ERR」

- **正規化**：

  - `-0` は `0` に正規化して表示
  - 先頭 `+` は表示しない

---

# 5. 代表的な動作の例（頭の中のトレース練習）

- **`1 + 2 * 3`**

  - 変換：`1 2 3 * +`
  - 評価：`2*3=6` → `1+6=7`

- **`8 / 2 / 2`**（左結合）

  - 変換：`8 2 / 2 /`
  - 評価：`8/2=4` → `4/2=2`

- **`10 - 2 * 3`**（乗除優先）

  - 変換：`10 2 3 * -`
  - 評価：`2*3=6` → `10-6=4`

- **`-3 * 5`**（単項マイナス）

  - トークン：`-3`、`*`、`5`
  - 変換：`-3 5 *`
  - 評価：`-15`

---

# 6. エラーの扱い（UI に返す観点）

- **中間結果でのオーバーフロー**：その時点でエラー（以降は計算しない）
- **ゼロ割り**：エラー
- **オペランド不足**（演算子に対する数が足りない）
- **未知の文字**、空入力
  → いずれも UI では **「ERR」** 表示に統一。復帰は `AC`。

---

# 7. テストに落とし込む観点（コードなし）

- **優先順位／結合性**

  - `1+2*3 → 7`
  - `8/2/2 → 2`（左結合）
  - `10-2*3 → 4`

- **足し算**

  - 正常、最大・最小境界（±99,999,999 近辺）、8 桁超えは ERR

- **引き算**

  - 正常、正負混在、`X-0` と `0-X`

- **掛け算**

  - 正常、`×0`、8 桁超えは ERR

- **割り算**

  - 正常、0 割りは ERR、0 方向丸めの確認

- **単項マイナス**

  - 先頭マイナス、演算子直後のマイナス

- **入力エラー**

  - 不正文字、演算子の連続、空式

- **エラーからの復帰**

  - `AC` で初期化、`C` の扱いは UI 設計に準拠

---

# 8. UI との分離設計

- **計算モジュール**：

  - 「文字列 → 結果 or エラー」を返す純粋関数のイメージ
  - エラーは **種別** を持つ（ゼロ割／オーバーフロー／構文）

- **UI**：

  - 入力桁数の制御（最大 8 桁）
  - エラー表示（ERR）
  - `C`/`AC` の状態遷移
  - `=` 直後の入力の扱い（新規入力として上書き、など）

---

# 9. よくあるつまずき（回避策）

- **単項マイナスを二項演算子として処理してしまう**
  → 「式頭」「演算子直後」の `-` は符号として数値に吸収するルールで明確化
- **左結合の実装ミス**
  → 同優先の演算子は、先に来たものを先に出す（変換時）
- **割り算の丸めが仕様と違う**
  → 0 方向丸めか、切り捨てか、四捨五入かを最初に決めて統一
- **中間結果の 8 桁判定を忘れる**
  → 各演算の直後に絶対値チェック
- **ERR 後の操作が曖昧**
  → `AC` でしか復帰しない、などのルールを定義してテスト化

---

この方針なら、**コードを書かずに**でも仕様・テスト・内部設計を固められます。
次はこの設計をベースに、あなたの事前テスト項目へ**ひとつずつ落とし込む表**を作ることもできます。作りましょうか？
